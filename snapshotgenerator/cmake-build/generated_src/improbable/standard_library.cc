// Generated by SpatialOS codegen. DO NOT EDIT!
// source: improbable/standard_library.schema
#include "improbable/standard_library.h"

namespace improbable {

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Write_ComponentInterest(
    const ::improbable::ComponentInterest& data, ::worker::detail::internal::Pbio_Object* object) {
  for (const auto& item : data.queries()) {
    ::improbable::detail::Write_ComponentInterest_Query(item, ::worker::detail::internal::Pbio_AddObject(object, 1));
  }
}

::improbable::ComponentInterest Read_ComponentInterest(::worker::detail::internal::Pbio_Object* object) {
  ::worker::List< ::improbable::ComponentInterest_Query > _queries;
  auto _queries_count = ::worker::detail::internal::Pbio_GetObjectCount(object, 1);
  for (std::uint32_t index = 0; index < _queries_count; ++index) {
    _queries.emplace_back(::improbable::detail::Read_ComponentInterest_Query(::worker::detail::internal::Pbio_IndexObject(object, 1, index)));
  }
  return {
      std::move(_queries)};
}

void Write_Coordinates(
    const ::improbable::Coordinates& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddDouble(object, 1, data.x());
  ::worker::detail::internal::Pbio_AddDouble(object, 2, data.y());
  ::worker::detail::internal::Pbio_AddDouble(object, 3, data.z());
}

::improbable::Coordinates Read_Coordinates(::worker::detail::internal::Pbio_Object* object) {
  auto _x = ::worker::detail::internal::Pbio_GetDouble(object, 1);
  auto _y = ::worker::detail::internal::Pbio_GetDouble(object, 2);
  auto _z = ::worker::detail::internal::Pbio_GetDouble(object, 3);
  return {
      std::move(_x),
      std::move(_y),
      std::move(_z)};
}

void Write_EdgeLength(
    const ::improbable::EdgeLength& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddDouble(object, 1, data.x());
  ::worker::detail::internal::Pbio_AddDouble(object, 2, data.y());
  ::worker::detail::internal::Pbio_AddDouble(object, 3, data.z());
}

::improbable::EdgeLength Read_EdgeLength(::worker::detail::internal::Pbio_Object* object) {
  auto _x = ::worker::detail::internal::Pbio_GetDouble(object, 1);
  auto _y = ::worker::detail::internal::Pbio_GetDouble(object, 2);
  auto _z = ::worker::detail::internal::Pbio_GetDouble(object, 3);
  return {
      std::move(_x),
      std::move(_y),
      std::move(_z)};
}

void Write_ComponentInterest_BoxConstraint(
    const ::improbable::ComponentInterest_BoxConstraint& data, ::worker::detail::internal::Pbio_Object* object) {
  ::improbable::detail::Write_Coordinates(data.center(), ::worker::detail::internal::Pbio_AddObject(object, 1));
  ::improbable::detail::Write_EdgeLength(data.edge_length(), ::worker::detail::internal::Pbio_AddObject(object, 2));
}

::improbable::ComponentInterest_BoxConstraint Read_ComponentInterest_BoxConstraint(::worker::detail::internal::Pbio_Object* object) {
  auto _center = ::improbable::detail::Read_Coordinates(::worker::detail::internal::Pbio_GetObject(object, 1));
  auto _edge_length = ::improbable::detail::Read_EdgeLength(::worker::detail::internal::Pbio_GetObject(object, 2));
  return {
      std::move(_center),
      std::move(_edge_length)};
}

void Write_ComponentInterest_CylinderConstraint(
    const ::improbable::ComponentInterest_CylinderConstraint& data, ::worker::detail::internal::Pbio_Object* object) {
  ::improbable::detail::Write_Coordinates(data.center(), ::worker::detail::internal::Pbio_AddObject(object, 1));
  ::worker::detail::internal::Pbio_AddDouble(object, 2, data.radius());
}

::improbable::ComponentInterest_CylinderConstraint Read_ComponentInterest_CylinderConstraint(::worker::detail::internal::Pbio_Object* object) {
  auto _center = ::improbable::detail::Read_Coordinates(::worker::detail::internal::Pbio_GetObject(object, 1));
  auto _radius = ::worker::detail::internal::Pbio_GetDouble(object, 2);
  return {
      std::move(_center),
      std::move(_radius)};
}

void Write_ComponentInterest_QueryConstraint(
    const ::improbable::ComponentInterest_QueryConstraint& data, ::worker::detail::internal::Pbio_Object* object) {
  if (data.sphere_constraint()) {
    ::improbable::detail::Write_ComponentInterest_SphereConstraint((*data.sphere_constraint()), ::worker::detail::internal::Pbio_AddObject(object, 1));
  }
  if (data.cylinder_constraint()) {
    ::improbable::detail::Write_ComponentInterest_CylinderConstraint((*data.cylinder_constraint()), ::worker::detail::internal::Pbio_AddObject(object, 2));
  }
  if (data.box_constraint()) {
    ::improbable::detail::Write_ComponentInterest_BoxConstraint((*data.box_constraint()), ::worker::detail::internal::Pbio_AddObject(object, 3));
  }
  if (data.relative_sphere_constraint()) {
    ::improbable::detail::Write_ComponentInterest_RelativeSphereConstraint((*data.relative_sphere_constraint()), ::worker::detail::internal::Pbio_AddObject(object, 4));
  }
  if (data.relative_cylinder_constraint()) {
    ::improbable::detail::Write_ComponentInterest_RelativeCylinderConstraint((*data.relative_cylinder_constraint()), ::worker::detail::internal::Pbio_AddObject(object, 5));
  }
  if (data.relative_box_constraint()) {
    ::improbable::detail::Write_ComponentInterest_RelativeBoxConstraint((*data.relative_box_constraint()), ::worker::detail::internal::Pbio_AddObject(object, 6));
  }
  if (data.entity_id_constraint()) {
    ::worker::detail::internal::Pbio_AddInt64(object, 7, (*data.entity_id_constraint()));
  }
  if (data.component_constraint()) {
    ::worker::detail::internal::Pbio_AddUint32(object, 8, (*data.component_constraint()));
  }
  for (const auto& item : data.and_constraint()) {
    ::improbable::detail::Write_ComponentInterest_QueryConstraint(item, ::worker::detail::internal::Pbio_AddObject(object, 9));
  }
  for (const auto& item : data.or_constraint()) {
    ::improbable::detail::Write_ComponentInterest_QueryConstraint(item, ::worker::detail::internal::Pbio_AddObject(object, 10));
  }
}

::improbable::ComponentInterest_QueryConstraint Read_ComponentInterest_QueryConstraint(::worker::detail::internal::Pbio_Object* object) {
  ::worker::Option< ::improbable::ComponentInterest_SphereConstraint > _sphere_constraint;
  if (::worker::detail::internal::Pbio_GetObjectCount(object, 1)) {
    _sphere_constraint.emplace(::improbable::detail::Read_ComponentInterest_SphereConstraint(::worker::detail::internal::Pbio_GetObject(object, 1)));
  }
  ::worker::Option< ::improbable::ComponentInterest_CylinderConstraint > _cylinder_constraint;
  if (::worker::detail::internal::Pbio_GetObjectCount(object, 2)) {
    _cylinder_constraint.emplace(::improbable::detail::Read_ComponentInterest_CylinderConstraint(::worker::detail::internal::Pbio_GetObject(object, 2)));
  }
  ::worker::Option< ::improbable::ComponentInterest_BoxConstraint > _box_constraint;
  if (::worker::detail::internal::Pbio_GetObjectCount(object, 3)) {
    _box_constraint.emplace(::improbable::detail::Read_ComponentInterest_BoxConstraint(::worker::detail::internal::Pbio_GetObject(object, 3)));
  }
  ::worker::Option< ::improbable::ComponentInterest_RelativeSphereConstraint > _relative_sphere_constraint;
  if (::worker::detail::internal::Pbio_GetObjectCount(object, 4)) {
    _relative_sphere_constraint.emplace(::improbable::detail::Read_ComponentInterest_RelativeSphereConstraint(::worker::detail::internal::Pbio_GetObject(object, 4)));
  }
  ::worker::Option< ::improbable::ComponentInterest_RelativeCylinderConstraint > _relative_cylinder_constraint;
  if (::worker::detail::internal::Pbio_GetObjectCount(object, 5)) {
    _relative_cylinder_constraint.emplace(::improbable::detail::Read_ComponentInterest_RelativeCylinderConstraint(::worker::detail::internal::Pbio_GetObject(object, 5)));
  }
  ::worker::Option< ::improbable::ComponentInterest_RelativeBoxConstraint > _relative_box_constraint;
  if (::worker::detail::internal::Pbio_GetObjectCount(object, 6)) {
    _relative_box_constraint.emplace(::improbable::detail::Read_ComponentInterest_RelativeBoxConstraint(::worker::detail::internal::Pbio_GetObject(object, 6)));
  }
  ::worker::Option< std::int64_t > _entity_id_constraint;
  if (::worker::detail::internal::Pbio_GetInt64Count(object, 7)) {
    _entity_id_constraint.emplace(::worker::detail::internal::Pbio_GetInt64(object, 7));
  }
  ::worker::Option< std::uint32_t > _component_constraint;
  if (::worker::detail::internal::Pbio_GetUint32Count(object, 8)) {
    _component_constraint.emplace(::worker::detail::internal::Pbio_GetUint32(object, 8));
  }
  ::worker::List< ::improbable::ComponentInterest_QueryConstraint > _and_constraint;
  auto _and_constraint_count = ::worker::detail::internal::Pbio_GetObjectCount(object, 9);
  for (std::uint32_t index = 0; index < _and_constraint_count; ++index) {
    _and_constraint.emplace_back(::improbable::detail::Read_ComponentInterest_QueryConstraint(::worker::detail::internal::Pbio_IndexObject(object, 9, index)));
  }
  ::worker::List< ::improbable::ComponentInterest_QueryConstraint > _or_constraint;
  auto _or_constraint_count = ::worker::detail::internal::Pbio_GetObjectCount(object, 10);
  for (std::uint32_t index = 0; index < _or_constraint_count; ++index) {
    _or_constraint.emplace_back(::improbable::detail::Read_ComponentInterest_QueryConstraint(::worker::detail::internal::Pbio_IndexObject(object, 10, index)));
  }
  return {
      std::move(_sphere_constraint),
      std::move(_cylinder_constraint),
      std::move(_box_constraint),
      std::move(_relative_sphere_constraint),
      std::move(_relative_cylinder_constraint),
      std::move(_relative_box_constraint),
      std::move(_entity_id_constraint),
      std::move(_component_constraint),
      std::move(_and_constraint),
      std::move(_or_constraint)};
}

void Write_ComponentInterest_Query(
    const ::improbable::ComponentInterest_Query& data, ::worker::detail::internal::Pbio_Object* object) {
  ::improbable::detail::Write_ComponentInterest_QueryConstraint(data.constraint(), ::worker::detail::internal::Pbio_AddObject(object, 1));
  if (data.full_snapshot_result()) {
    ::worker::detail::internal::Pbio_AddBool(object, 2, static_cast<std::uint8_t>((*data.full_snapshot_result())));
  }
  ::worker::detail::internal::Pbio_AddUint32List(object, 3, data.result_component_id().data(), static_cast<std::uint32_t>(data.result_component_id().size()));
  if (data.frequency()) {
    ::worker::detail::internal::Pbio_AddFloat(object, 4, (*data.frequency()));
  }
}

::improbable::ComponentInterest_Query Read_ComponentInterest_Query(::worker::detail::internal::Pbio_Object* object) {
  auto _constraint = ::improbable::detail::Read_ComponentInterest_QueryConstraint(::worker::detail::internal::Pbio_GetObject(object, 1));
  ::worker::Option< bool > _full_snapshot_result;
  if (::worker::detail::internal::Pbio_GetBoolCount(object, 2)) {
    _full_snapshot_result.emplace(::worker::detail::internal::Pbio_GetBool(object, 2) != 0);
  }
  ::worker::List< std::uint32_t > _result_component_id;
  auto _result_component_id_count = ::worker::detail::internal::Pbio_GetUint32Count(object, 3);
  _result_component_id.insert(_result_component_id.end(), static_cast<std::size_t>(_result_component_id_count), 0);
  ::worker::detail::internal::Pbio_GetUint32List(object, 3, _result_component_id.data());
  ::worker::Option< float > _frequency;
  if (::worker::detail::internal::Pbio_GetFloatCount(object, 4)) {
    _frequency.emplace(::worker::detail::internal::Pbio_GetFloat(object, 4));
  }
  return {
      std::move(_constraint),
      std::move(_full_snapshot_result),
      std::move(_result_component_id),
      std::move(_frequency)};
}

void Write_ComponentInterest_RelativeBoxConstraint(
    const ::improbable::ComponentInterest_RelativeBoxConstraint& data, ::worker::detail::internal::Pbio_Object* object) {
  ::improbable::detail::Write_EdgeLength(data.edge_length(), ::worker::detail::internal::Pbio_AddObject(object, 1));
}

::improbable::ComponentInterest_RelativeBoxConstraint Read_ComponentInterest_RelativeBoxConstraint(::worker::detail::internal::Pbio_Object* object) {
  auto _edge_length = ::improbable::detail::Read_EdgeLength(::worker::detail::internal::Pbio_GetObject(object, 1));
  return {
      std::move(_edge_length)};
}

void Write_ComponentInterest_RelativeCylinderConstraint(
    const ::improbable::ComponentInterest_RelativeCylinderConstraint& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddDouble(object, 1, data.radius());
}

::improbable::ComponentInterest_RelativeCylinderConstraint Read_ComponentInterest_RelativeCylinderConstraint(::worker::detail::internal::Pbio_Object* object) {
  auto _radius = ::worker::detail::internal::Pbio_GetDouble(object, 1);
  return {
      std::move(_radius)};
}

void Write_ComponentInterest_RelativeSphereConstraint(
    const ::improbable::ComponentInterest_RelativeSphereConstraint& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddDouble(object, 1, data.radius());
}

::improbable::ComponentInterest_RelativeSphereConstraint Read_ComponentInterest_RelativeSphereConstraint(::worker::detail::internal::Pbio_Object* object) {
  auto _radius = ::worker::detail::internal::Pbio_GetDouble(object, 1);
  return {
      std::move(_radius)};
}

void Write_ComponentInterest_SphereConstraint(
    const ::improbable::ComponentInterest_SphereConstraint& data, ::worker::detail::internal::Pbio_Object* object) {
  ::improbable::detail::Write_Coordinates(data.center(), ::worker::detail::internal::Pbio_AddObject(object, 1));
  ::worker::detail::internal::Pbio_AddDouble(object, 2, data.radius());
}

::improbable::ComponentInterest_SphereConstraint Read_ComponentInterest_SphereConstraint(::worker::detail::internal::Pbio_Object* object) {
  auto _center = ::improbable::detail::Read_Coordinates(::worker::detail::internal::Pbio_GetObject(object, 1));
  auto _radius = ::worker::detail::internal::Pbio_GetDouble(object, 2);
  return {
      std::move(_center),
      std::move(_radius)};
}

void Write_WorkerRequirementSet(
    const ::improbable::WorkerRequirementSet& data, ::worker::detail::internal::Pbio_Object* object) {
  for (const auto& item : data.attribute_set()) {
    ::improbable::detail::Write_WorkerAttributeSet(item, ::worker::detail::internal::Pbio_AddObject(object, 1));
  }
}

::improbable::WorkerRequirementSet Read_WorkerRequirementSet(::worker::detail::internal::Pbio_Object* object) {
  ::worker::List< ::improbable::WorkerAttributeSet > _attribute_set;
  auto _attribute_set_count = ::worker::detail::internal::Pbio_GetObjectCount(object, 1);
  for (std::uint32_t index = 0; index < _attribute_set_count; ++index) {
    _attribute_set.emplace_back(::improbable::detail::Read_WorkerAttributeSet(::worker::detail::internal::Pbio_IndexObject(object, 1, index)));
  }
  return {
      std::move(_attribute_set)};
}

void Write_EntityAclData(
    const ::improbable::EntityAclData& data, ::worker::detail::internal::Pbio_Object* object) {
  ::improbable::detail::Write_WorkerRequirementSet(data.read_acl(), ::worker::detail::internal::Pbio_AddObject(object, 1));
  for (const auto& item : data.component_write_acl()) {
    auto pair = ::worker::detail::internal::Pbio_AddObject(object, 2);
    ::worker::detail::internal::Pbio_AddUint32(pair, 1, item.first);
    ::improbable::detail::Write_WorkerRequirementSet(item.second, ::worker::detail::internal::Pbio_AddObject(pair, 2));
  }
}

::improbable::EntityAclData Read_EntityAclData(::worker::detail::internal::Pbio_Object* object) {
  auto _read_acl = ::improbable::detail::Read_WorkerRequirementSet(::worker::detail::internal::Pbio_GetObject(object, 1));
  ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > _component_write_acl;
  auto _component_write_acl_count = ::worker::detail::internal::Pbio_GetObjectCount(object, 2);
  for (std::uint32_t index = 0; index < _component_write_acl_count; ++index) {
    auto pair = ::worker::detail::internal::Pbio_IndexObject(object, 2, index);
    _component_write_acl.emplace(::worker::detail::internal::Pbio_GetUint32(pair, 1), ::improbable::detail::Read_WorkerRequirementSet(::worker::detail::internal::Pbio_GetObject(pair, 2)));
  }
  return {
      std::move(_read_acl),
      std::move(_component_write_acl)};
}

void Write_InterestData(
    const ::improbable::InterestData& data, ::worker::detail::internal::Pbio_Object* object) {
  for (const auto& item : data.component_interest()) {
    auto pair = ::worker::detail::internal::Pbio_AddObject(object, 1);
    ::worker::detail::internal::Pbio_AddUint32(pair, 1, item.first);
    ::improbable::detail::Write_ComponentInterest(item.second, ::worker::detail::internal::Pbio_AddObject(pair, 2));
  }
}

::improbable::InterestData Read_InterestData(::worker::detail::internal::Pbio_Object* object) {
  ::worker::Map< std::uint32_t, ::improbable::ComponentInterest > _component_interest;
  auto _component_interest_count = ::worker::detail::internal::Pbio_GetObjectCount(object, 1);
  for (std::uint32_t index = 0; index < _component_interest_count; ++index) {
    auto pair = ::worker::detail::internal::Pbio_IndexObject(object, 1, index);
    _component_interest.emplace(::worker::detail::internal::Pbio_GetUint32(pair, 1), ::improbable::detail::Read_ComponentInterest(::worker::detail::internal::Pbio_GetObject(pair, 2)));
  }
  return {
      std::move(_component_interest)};
}

void Write_MetadataData(
    const ::improbable::MetadataData& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddBytes(object, 1, reinterpret_cast<const std::uint8_t*>(data.entity_type().data()), static_cast<std::uint32_t>(data.entity_type().size()));
}

::improbable::MetadataData Read_MetadataData(::worker::detail::internal::Pbio_Object* object) {
  auto _entity_type = [object] { auto _buffer = reinterpret_cast<const char*>(::worker::detail::internal::Pbio_GetBytes(object, 1)); return std::string{_buffer, _buffer + ::worker::detail::internal::Pbio_GetBytesLength(object, 1)}; }();
  return {
      std::move(_entity_type)};
}

void Write_PersistenceData(const ::improbable::PersistenceData&, ::worker::detail::internal::Pbio_Object*) {}

::improbable::PersistenceData Read_PersistenceData(::worker::detail::internal::Pbio_Object*) {
  return {};
}

void Write_PositionData(
    const ::improbable::PositionData& data, ::worker::detail::internal::Pbio_Object* object) {
  ::improbable::detail::Write_Coordinates(data.coords(), ::worker::detail::internal::Pbio_AddObject(object, 1));
}

::improbable::PositionData Read_PositionData(::worker::detail::internal::Pbio_Object* object) {
  auto _coords = ::improbable::detail::Read_Coordinates(::worker::detail::internal::Pbio_GetObject(object, 1));
  return {
      std::move(_coords)};
}

void Write_WorkerAttributeSet(
    const ::improbable::WorkerAttributeSet& data, ::worker::detail::internal::Pbio_Object* object) {
  for (const auto& item : data.attribute()) {
    ::worker::detail::internal::Pbio_AddBytes(object, 1, reinterpret_cast<const std::uint8_t*>(item.data()), static_cast<std::uint32_t>(item.size()));
  }
}

::improbable::WorkerAttributeSet Read_WorkerAttributeSet(::worker::detail::internal::Pbio_Object* object) {
  ::worker::List< std::string > _attribute;
  auto _attribute_count = ::worker::detail::internal::Pbio_GetBytesCount(object, 1);
  for (std::uint32_t index = 0; index < _attribute_count; ++index) {
    auto _buffer = reinterpret_cast<const char*>(::worker::detail::internal::Pbio_IndexBytes(object, 1, index));
    _attribute.emplace_back(_buffer, _buffer + ::worker::detail::internal::Pbio_IndexBytesLength(object, 1, index));
  }
  return {
      std::move(_attribute)};
}

namespace {

void VtableFree_EntityAcl(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::improbable::EntityAcl::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::improbable::EntityAclData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_EntityAcl >::free(handle);
  }
}

void* VtableCopy_EntityAcl(
    ::worker::ComponentId, void*, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::improbable::EntityAcl::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::improbable::EntityAclData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_EntityAcl >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_EntityAcl(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::EntityAcl::Update >::allocate();
    auto* object =
       &::worker::detail::ClientHandle< ::improbable::EntityAcl::Update >::get_mutable(*handle_out);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::worker::detail::internal::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::worker::detail::internal::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::worker::detail::internal::Pbio_GetObject(
          ::worker::detail::internal::Pbio_GetObject(root, /* entity_state */ 2), 50);
      if (::worker::detail::internal::Pbio_GetObjectCount(state_object, 1)) {
        auto _read_acl = ::improbable::detail::Read_WorkerRequirementSet(::worker::detail::internal::Pbio_GetObject(state_object, 1));
        object->read_acl().emplace(std::move(_read_acl));
      }
      if (::worker::detail::internal::Pbio_GetObjectCount(state_object, 2) || fields_to_clear.count(2)) {
        ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > _component_write_acl;
        auto _component_write_acl_count = ::worker::detail::internal::Pbio_GetObjectCount(state_object, 2);
        for (std::uint32_t index = 0; index < _component_write_acl_count; ++index) {
          auto pair = ::worker::detail::internal::Pbio_IndexObject(state_object, 2, index);
          _component_write_acl.emplace(::worker::detail::internal::Pbio_GetUint32(pair, 1), ::improbable::detail::Read_WorkerRequirementSet(::worker::detail::internal::Pbio_GetObject(pair, 2)));
        }
        object->component_write_acl().emplace(std::move(_component_write_acl));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::EntityAclData >::allocate(::improbable::detail::Read_EntityAclData(::worker::detail::internal::Pbio_GetObject(root, 50)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
  }
  return true;
}

void VtableSerialize_EntityAcl(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    const auto& data = ::worker::detail::ClientHandle< ::improbable::EntityAcl::Update >::get(handle);
    {
      auto state_object = ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 50);
      if (data.read_acl()) {
        ::improbable::detail::Write_WorkerRequirementSet((*data.read_acl()), ::worker::detail::internal::Pbio_AddObject(state_object, 1));
      }
      if (data.component_write_acl()) {
        if (data.component_write_acl()->empty()) {
          ::worker::detail::internal::Pbio_AddUint32(root, /* fields_to_clear */ 1, 2);
        }
        for (const auto& item : (*data.component_write_acl())) {
          auto pair = ::worker::detail::internal::Pbio_AddObject(state_object, 2);
          ::worker::detail::internal::Pbio_AddUint32(pair, 1, item.first);
          ::improbable::detail::Write_WorkerRequirementSet(item.second, ::worker::detail::internal::Pbio_AddObject(pair, 2));
        }
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::improbable::detail::Write_EntityAclData(
        ::worker::detail::ClientHandle< ::improbable::EntityAclData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 50));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    ::worker::detail::internal::Pbio_AddObject(root, 50);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::internal::Pbio_AddObject(root, 50);
  }
}

}  // anonymous namespace

namespace {

void VtableFree_Metadata(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::improbable::Metadata::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::improbable::MetadataData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_Metadata >::free(handle);
  }
}

void* VtableCopy_Metadata(
    ::worker::ComponentId, void*, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::improbable::Metadata::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::improbable::MetadataData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_Metadata >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_Metadata(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::Metadata::Update >::allocate();
    auto* object =
       &::worker::detail::ClientHandle< ::improbable::Metadata::Update >::get_mutable(*handle_out);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::worker::detail::internal::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::worker::detail::internal::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::worker::detail::internal::Pbio_GetObject(
          ::worker::detail::internal::Pbio_GetObject(root, /* entity_state */ 2), 53);
      if (::worker::detail::internal::Pbio_GetBytesCount(state_object, 1)) {
        auto _entity_type = [state_object] { auto _buffer = reinterpret_cast<const char*>(::worker::detail::internal::Pbio_GetBytes(state_object, 1)); return std::string{_buffer, _buffer + ::worker::detail::internal::Pbio_GetBytesLength(state_object, 1)}; }();
        object->entity_type().emplace(std::move(_entity_type));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::MetadataData >::allocate(::improbable::detail::Read_MetadataData(::worker::detail::internal::Pbio_GetObject(root, 53)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
  }
  return true;
}

void VtableSerialize_Metadata(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    const auto& data = ::worker::detail::ClientHandle< ::improbable::Metadata::Update >::get(handle);
    {
      auto state_object = ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 53);
      if (data.entity_type()) {
        ::worker::detail::internal::Pbio_AddBytes(state_object, 1, reinterpret_cast<const std::uint8_t*>((*data.entity_type()).data()), static_cast<std::uint32_t>((*data.entity_type()).size()));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::improbable::detail::Write_MetadataData(
        ::worker::detail::ClientHandle< ::improbable::MetadataData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 53));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    ::worker::detail::internal::Pbio_AddObject(root, 53);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::internal::Pbio_AddObject(root, 53);
  }
}

}  // anonymous namespace

namespace {

void VtableFree_Position(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::improbable::Position::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::improbable::PositionData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_Position >::free(handle);
  }
}

void* VtableCopy_Position(
    ::worker::ComponentId, void*, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::improbable::Position::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::improbable::PositionData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_Position >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_Position(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::Position::Update >::allocate();
    auto* object =
       &::worker::detail::ClientHandle< ::improbable::Position::Update >::get_mutable(*handle_out);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::worker::detail::internal::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::worker::detail::internal::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::worker::detail::internal::Pbio_GetObject(
          ::worker::detail::internal::Pbio_GetObject(root, /* entity_state */ 2), 54);
      if (::worker::detail::internal::Pbio_GetObjectCount(state_object, 1)) {
        auto _coords = ::improbable::detail::Read_Coordinates(::worker::detail::internal::Pbio_GetObject(state_object, 1));
        object->coords().emplace(std::move(_coords));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::PositionData >::allocate(::improbable::detail::Read_PositionData(::worker::detail::internal::Pbio_GetObject(root, 54)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
  }
  return true;
}

void VtableSerialize_Position(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    const auto& data = ::worker::detail::ClientHandle< ::improbable::Position::Update >::get(handle);
    {
      auto state_object = ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 54);
      if (data.coords()) {
        ::improbable::detail::Write_Coordinates((*data.coords()), ::worker::detail::internal::Pbio_AddObject(state_object, 1));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::improbable::detail::Write_PositionData(
        ::worker::detail::ClientHandle< ::improbable::PositionData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 54));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    ::worker::detail::internal::Pbio_AddObject(root, 54);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::internal::Pbio_AddObject(root, 54);
  }
}

}  // anonymous namespace

namespace {

void VtableFree_Persistence(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::improbable::Persistence::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::improbable::PersistenceData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_Persistence >::free(handle);
  }
}

void* VtableCopy_Persistence(
    ::worker::ComponentId, void*, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::improbable::Persistence::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::improbable::PersistenceData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_Persistence >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_Persistence(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::Persistence::Update >::allocate();
    {
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::PersistenceData >::allocate(::improbable::detail::Read_PersistenceData(::worker::detail::internal::Pbio_GetObject(root, 55)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
  }
  return true;
}

void VtableSerialize_Persistence(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    {
      ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 55);
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::improbable::detail::Write_PersistenceData(
        ::worker::detail::ClientHandle< ::improbable::PersistenceData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 55));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    ::worker::detail::internal::Pbio_AddObject(root, 55);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::internal::Pbio_AddObject(root, 55);
  }
}

}  // anonymous namespace

namespace {

void VtableFree_Interest(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::improbable::Interest::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::improbable::InterestData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_Interest >::free(handle);
  }
}

void* VtableCopy_Interest(
    ::worker::ComponentId, void*, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::improbable::Interest::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::improbable::InterestData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_Interest >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_Interest(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::Interest::Update >::allocate();
    auto* object =
       &::worker::detail::ClientHandle< ::improbable::Interest::Update >::get_mutable(*handle_out);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::worker::detail::internal::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::worker::detail::internal::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::worker::detail::internal::Pbio_GetObject(
          ::worker::detail::internal::Pbio_GetObject(root, /* entity_state */ 2), 58);
      if (::worker::detail::internal::Pbio_GetObjectCount(state_object, 1) || fields_to_clear.count(1)) {
        ::worker::Map< std::uint32_t, ::improbable::ComponentInterest > _component_interest;
        auto _component_interest_count = ::worker::detail::internal::Pbio_GetObjectCount(state_object, 1);
        for (std::uint32_t index = 0; index < _component_interest_count; ++index) {
          auto pair = ::worker::detail::internal::Pbio_IndexObject(state_object, 1, index);
          _component_interest.emplace(::worker::detail::internal::Pbio_GetUint32(pair, 1), ::improbable::detail::Read_ComponentInterest(::worker::detail::internal::Pbio_GetObject(pair, 2)));
        }
        object->component_interest().emplace(std::move(_component_interest));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::InterestData >::allocate(::improbable::detail::Read_InterestData(::worker::detail::internal::Pbio_GetObject(root, 58)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
  }
  return true;
}

void VtableSerialize_Interest(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    const auto& data = ::worker::detail::ClientHandle< ::improbable::Interest::Update >::get(handle);
    {
      auto state_object = ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 58);
      if (data.component_interest()) {
        if (data.component_interest()->empty()) {
          ::worker::detail::internal::Pbio_AddUint32(root, /* fields_to_clear */ 1, 1);
        }
        for (const auto& item : (*data.component_interest())) {
          auto pair = ::worker::detail::internal::Pbio_AddObject(state_object, 1);
          ::worker::detail::internal::Pbio_AddUint32(pair, 1, item.first);
          ::improbable::detail::Write_ComponentInterest(item.second, ::worker::detail::internal::Pbio_AddObject(pair, 2));
        }
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::improbable::detail::Write_InterestData(
        ::worker::detail::ClientHandle< ::improbable::InterestData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 58));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    ::worker::detail::internal::Pbio_AddObject(root, 58);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::internal::Pbio_AddObject(root, 58);
  }
}

}  // anonymous namespace

}  // ::detail

// Implementation of ComponentInterest.
//----------------------------------------------------------------

ComponentInterest::ComponentInterest(const ::worker::List< ::improbable::ComponentInterest_Query >& queries)
: _queries{queries} {}

ComponentInterest::ComponentInterest() {}

bool ComponentInterest::operator==(const ComponentInterest& value) const {
  return
      _queries == value._queries;
}

bool ComponentInterest::operator!=(const ComponentInterest& value) const {
  return !operator==(value);
}

const ::worker::List< ::improbable::ComponentInterest_Query >& ComponentInterest::queries() const {
  return _queries;
}

::worker::List< ::improbable::ComponentInterest_Query >& ComponentInterest::queries() {
  return _queries;
}

ComponentInterest& ComponentInterest::set_queries(const ::worker::List< ::improbable::ComponentInterest_Query >& value) {
  _queries = value;
  return *this;
}

// Implementation of Coordinates.
//----------------------------------------------------------------

Coordinates::Coordinates(
    double x,
    double y,
    double z)
: _x{x}
, _y{y}
, _z{z} {}

Coordinates::Coordinates()
: _x{0}
, _y{0}
, _z{0} {}

bool Coordinates::operator==(const Coordinates& value) const {
  return
      _x == value._x &&
      _y == value._y &&
      _z == value._z;
}

bool Coordinates::operator!=(const Coordinates& value) const {
  return !operator==(value);
}

double Coordinates::x() const {
  return _x;
}

double& Coordinates::x() {
  return _x;
}

Coordinates& Coordinates::set_x(double value) {
  _x = value;
  return *this;
}

double Coordinates::y() const {
  return _y;
}

double& Coordinates::y() {
  return _y;
}

Coordinates& Coordinates::set_y(double value) {
  _y = value;
  return *this;
}

double Coordinates::z() const {
  return _z;
}

double& Coordinates::z() {
  return _z;
}

Coordinates& Coordinates::set_z(double value) {
  _z = value;
  return *this;
}

// Implementation of EdgeLength.
//----------------------------------------------------------------

EdgeLength::EdgeLength(
    double x,
    double y,
    double z)
: _x{x}
, _y{y}
, _z{z} {}

EdgeLength::EdgeLength()
: _x{0}
, _y{0}
, _z{0} {}

bool EdgeLength::operator==(const EdgeLength& value) const {
  return
      _x == value._x &&
      _y == value._y &&
      _z == value._z;
}

bool EdgeLength::operator!=(const EdgeLength& value) const {
  return !operator==(value);
}

double EdgeLength::x() const {
  return _x;
}

double& EdgeLength::x() {
  return _x;
}

EdgeLength& EdgeLength::set_x(double value) {
  _x = value;
  return *this;
}

double EdgeLength::y() const {
  return _y;
}

double& EdgeLength::y() {
  return _y;
}

EdgeLength& EdgeLength::set_y(double value) {
  _y = value;
  return *this;
}

double EdgeLength::z() const {
  return _z;
}

double& EdgeLength::z() {
  return _z;
}

EdgeLength& EdgeLength::set_z(double value) {
  _z = value;
  return *this;
}

// Implementation of ComponentInterest_BoxConstraint.
//----------------------------------------------------------------

ComponentInterest_BoxConstraint::ComponentInterest_BoxConstraint(
    const ::improbable::Coordinates& center,
    const ::improbable::EdgeLength& edge_length)
: _center{center}
, _edge_length{edge_length} {}

ComponentInterest_BoxConstraint::ComponentInterest_BoxConstraint() {}

bool ComponentInterest_BoxConstraint::operator==(const ComponentInterest_BoxConstraint& value) const {
  return
      _center == value._center &&
      _edge_length == value._edge_length;
}

bool ComponentInterest_BoxConstraint::operator!=(const ComponentInterest_BoxConstraint& value) const {
  return !operator==(value);
}

const ::improbable::Coordinates& ComponentInterest_BoxConstraint::center() const {
  return _center;
}

::improbable::Coordinates& ComponentInterest_BoxConstraint::center() {
  return _center;
}

ComponentInterest_BoxConstraint& ComponentInterest_BoxConstraint::set_center(const ::improbable::Coordinates& value) {
  _center = value;
  return *this;
}

const ::improbable::EdgeLength& ComponentInterest_BoxConstraint::edge_length() const {
  return _edge_length;
}

::improbable::EdgeLength& ComponentInterest_BoxConstraint::edge_length() {
  return _edge_length;
}

ComponentInterest_BoxConstraint& ComponentInterest_BoxConstraint::set_edge_length(const ::improbable::EdgeLength& value) {
  _edge_length = value;
  return *this;
}

// Implementation of ComponentInterest_CylinderConstraint.
//----------------------------------------------------------------

ComponentInterest_CylinderConstraint::ComponentInterest_CylinderConstraint(
    const ::improbable::Coordinates& center,
    double radius)
: _center{center}
, _radius{radius} {}

ComponentInterest_CylinderConstraint::ComponentInterest_CylinderConstraint()
: _radius{0} {}

bool ComponentInterest_CylinderConstraint::operator==(const ComponentInterest_CylinderConstraint& value) const {
  return
      _center == value._center &&
      _radius == value._radius;
}

bool ComponentInterest_CylinderConstraint::operator!=(const ComponentInterest_CylinderConstraint& value) const {
  return !operator==(value);
}

const ::improbable::Coordinates& ComponentInterest_CylinderConstraint::center() const {
  return _center;
}

::improbable::Coordinates& ComponentInterest_CylinderConstraint::center() {
  return _center;
}

ComponentInterest_CylinderConstraint& ComponentInterest_CylinderConstraint::set_center(const ::improbable::Coordinates& value) {
  _center = value;
  return *this;
}

double ComponentInterest_CylinderConstraint::radius() const {
  return _radius;
}

double& ComponentInterest_CylinderConstraint::radius() {
  return _radius;
}

ComponentInterest_CylinderConstraint& ComponentInterest_CylinderConstraint::set_radius(double value) {
  _radius = value;
  return *this;
}

// Implementation of ComponentInterest_QueryConstraint.
//----------------------------------------------------------------

ComponentInterest_QueryConstraint::ComponentInterest_QueryConstraint(
    const ::worker::Option< ::improbable::ComponentInterest_SphereConstraint >& sphere_constraint,
    const ::worker::Option< ::improbable::ComponentInterest_CylinderConstraint >& cylinder_constraint,
    const ::worker::Option< ::improbable::ComponentInterest_BoxConstraint >& box_constraint,
    const ::worker::Option< ::improbable::ComponentInterest_RelativeSphereConstraint >& relative_sphere_constraint,
    const ::worker::Option< ::improbable::ComponentInterest_RelativeCylinderConstraint >& relative_cylinder_constraint,
    const ::worker::Option< ::improbable::ComponentInterest_RelativeBoxConstraint >& relative_box_constraint,
    const ::worker::Option< std::int64_t >& entity_id_constraint,
    const ::worker::Option< std::uint32_t >& component_constraint,
    const ::worker::List< ::improbable::ComponentInterest_QueryConstraint >& and_constraint,
    const ::worker::List< ::improbable::ComponentInterest_QueryConstraint >& or_constraint)
: _sphere_constraint{sphere_constraint}
, _cylinder_constraint{cylinder_constraint}
, _box_constraint{box_constraint}
, _relative_sphere_constraint{relative_sphere_constraint}
, _relative_cylinder_constraint{relative_cylinder_constraint}
, _relative_box_constraint{relative_box_constraint}
, _entity_id_constraint{entity_id_constraint}
, _component_constraint{component_constraint}
, _and_constraint{and_constraint}
, _or_constraint{or_constraint} {}

ComponentInterest_QueryConstraint::ComponentInterest_QueryConstraint() {}

bool ComponentInterest_QueryConstraint::operator==(const ComponentInterest_QueryConstraint& value) const {
  return
      _sphere_constraint == value._sphere_constraint &&
      _cylinder_constraint == value._cylinder_constraint &&
      _box_constraint == value._box_constraint &&
      _relative_sphere_constraint == value._relative_sphere_constraint &&
      _relative_cylinder_constraint == value._relative_cylinder_constraint &&
      _relative_box_constraint == value._relative_box_constraint &&
      _entity_id_constraint == value._entity_id_constraint &&
      _component_constraint == value._component_constraint &&
      _and_constraint == value._and_constraint &&
      _or_constraint == value._or_constraint;
}

bool ComponentInterest_QueryConstraint::operator!=(const ComponentInterest_QueryConstraint& value) const {
  return !operator==(value);
}

const ::worker::Option< ::improbable::ComponentInterest_SphereConstraint >& ComponentInterest_QueryConstraint::sphere_constraint() const {
  return _sphere_constraint;
}

::worker::Option< ::improbable::ComponentInterest_SphereConstraint >& ComponentInterest_QueryConstraint::sphere_constraint() {
  return _sphere_constraint;
}

ComponentInterest_QueryConstraint& ComponentInterest_QueryConstraint::set_sphere_constraint(const ::worker::Option< ::improbable::ComponentInterest_SphereConstraint >& value) {
  _sphere_constraint = value;
  return *this;
}

const ::worker::Option< ::improbable::ComponentInterest_CylinderConstraint >& ComponentInterest_QueryConstraint::cylinder_constraint() const {
  return _cylinder_constraint;
}

::worker::Option< ::improbable::ComponentInterest_CylinderConstraint >& ComponentInterest_QueryConstraint::cylinder_constraint() {
  return _cylinder_constraint;
}

ComponentInterest_QueryConstraint& ComponentInterest_QueryConstraint::set_cylinder_constraint(const ::worker::Option< ::improbable::ComponentInterest_CylinderConstraint >& value) {
  _cylinder_constraint = value;
  return *this;
}

const ::worker::Option< ::improbable::ComponentInterest_BoxConstraint >& ComponentInterest_QueryConstraint::box_constraint() const {
  return _box_constraint;
}

::worker::Option< ::improbable::ComponentInterest_BoxConstraint >& ComponentInterest_QueryConstraint::box_constraint() {
  return _box_constraint;
}

ComponentInterest_QueryConstraint& ComponentInterest_QueryConstraint::set_box_constraint(const ::worker::Option< ::improbable::ComponentInterest_BoxConstraint >& value) {
  _box_constraint = value;
  return *this;
}

const ::worker::Option< ::improbable::ComponentInterest_RelativeSphereConstraint >& ComponentInterest_QueryConstraint::relative_sphere_constraint() const {
  return _relative_sphere_constraint;
}

::worker::Option< ::improbable::ComponentInterest_RelativeSphereConstraint >& ComponentInterest_QueryConstraint::relative_sphere_constraint() {
  return _relative_sphere_constraint;
}

ComponentInterest_QueryConstraint& ComponentInterest_QueryConstraint::set_relative_sphere_constraint(const ::worker::Option< ::improbable::ComponentInterest_RelativeSphereConstraint >& value) {
  _relative_sphere_constraint = value;
  return *this;
}

const ::worker::Option< ::improbable::ComponentInterest_RelativeCylinderConstraint >& ComponentInterest_QueryConstraint::relative_cylinder_constraint() const {
  return _relative_cylinder_constraint;
}

::worker::Option< ::improbable::ComponentInterest_RelativeCylinderConstraint >& ComponentInterest_QueryConstraint::relative_cylinder_constraint() {
  return _relative_cylinder_constraint;
}

ComponentInterest_QueryConstraint& ComponentInterest_QueryConstraint::set_relative_cylinder_constraint(const ::worker::Option< ::improbable::ComponentInterest_RelativeCylinderConstraint >& value) {
  _relative_cylinder_constraint = value;
  return *this;
}

const ::worker::Option< ::improbable::ComponentInterest_RelativeBoxConstraint >& ComponentInterest_QueryConstraint::relative_box_constraint() const {
  return _relative_box_constraint;
}

::worker::Option< ::improbable::ComponentInterest_RelativeBoxConstraint >& ComponentInterest_QueryConstraint::relative_box_constraint() {
  return _relative_box_constraint;
}

ComponentInterest_QueryConstraint& ComponentInterest_QueryConstraint::set_relative_box_constraint(const ::worker::Option< ::improbable::ComponentInterest_RelativeBoxConstraint >& value) {
  _relative_box_constraint = value;
  return *this;
}

const ::worker::Option< std::int64_t >& ComponentInterest_QueryConstraint::entity_id_constraint() const {
  return _entity_id_constraint;
}

::worker::Option< std::int64_t >& ComponentInterest_QueryConstraint::entity_id_constraint() {
  return _entity_id_constraint;
}

ComponentInterest_QueryConstraint& ComponentInterest_QueryConstraint::set_entity_id_constraint(const ::worker::Option< std::int64_t >& value) {
  _entity_id_constraint = value;
  return *this;
}

const ::worker::Option< std::uint32_t >& ComponentInterest_QueryConstraint::component_constraint() const {
  return _component_constraint;
}

::worker::Option< std::uint32_t >& ComponentInterest_QueryConstraint::component_constraint() {
  return _component_constraint;
}

ComponentInterest_QueryConstraint& ComponentInterest_QueryConstraint::set_component_constraint(const ::worker::Option< std::uint32_t >& value) {
  _component_constraint = value;
  return *this;
}

const ::worker::List< ::improbable::ComponentInterest_QueryConstraint >& ComponentInterest_QueryConstraint::and_constraint() const {
  return _and_constraint;
}

::worker::List< ::improbable::ComponentInterest_QueryConstraint >& ComponentInterest_QueryConstraint::and_constraint() {
  return _and_constraint;
}

ComponentInterest_QueryConstraint& ComponentInterest_QueryConstraint::set_and_constraint(const ::worker::List< ::improbable::ComponentInterest_QueryConstraint >& value) {
  _and_constraint = value;
  return *this;
}

const ::worker::List< ::improbable::ComponentInterest_QueryConstraint >& ComponentInterest_QueryConstraint::or_constraint() const {
  return _or_constraint;
}

::worker::List< ::improbable::ComponentInterest_QueryConstraint >& ComponentInterest_QueryConstraint::or_constraint() {
  return _or_constraint;
}

ComponentInterest_QueryConstraint& ComponentInterest_QueryConstraint::set_or_constraint(const ::worker::List< ::improbable::ComponentInterest_QueryConstraint >& value) {
  _or_constraint = value;
  return *this;
}

// Implementation of ComponentInterest_Query.
//----------------------------------------------------------------

ComponentInterest_Query::ComponentInterest_Query(
    const ::improbable::ComponentInterest_QueryConstraint& constraint,
    const ::worker::Option< bool >& full_snapshot_result,
    const ::worker::List< std::uint32_t >& result_component_id,
    const ::worker::Option< float >& frequency)
: _constraint{constraint}
, _full_snapshot_result{full_snapshot_result}
, _result_component_id{result_component_id}
, _frequency{frequency} {}

ComponentInterest_Query::ComponentInterest_Query() {}

bool ComponentInterest_Query::operator==(const ComponentInterest_Query& value) const {
  return
      _constraint == value._constraint &&
      _full_snapshot_result == value._full_snapshot_result &&
      _result_component_id == value._result_component_id &&
      _frequency == value._frequency;
}

bool ComponentInterest_Query::operator!=(const ComponentInterest_Query& value) const {
  return !operator==(value);
}

const ::improbable::ComponentInterest_QueryConstraint& ComponentInterest_Query::constraint() const {
  return _constraint;
}

::improbable::ComponentInterest_QueryConstraint& ComponentInterest_Query::constraint() {
  return _constraint;
}

ComponentInterest_Query& ComponentInterest_Query::set_constraint(const ::improbable::ComponentInterest_QueryConstraint& value) {
  _constraint = value;
  return *this;
}

const ::worker::Option< bool >& ComponentInterest_Query::full_snapshot_result() const {
  return _full_snapshot_result;
}

::worker::Option< bool >& ComponentInterest_Query::full_snapshot_result() {
  return _full_snapshot_result;
}

ComponentInterest_Query& ComponentInterest_Query::set_full_snapshot_result(const ::worker::Option< bool >& value) {
  _full_snapshot_result = value;
  return *this;
}

const ::worker::List< std::uint32_t >& ComponentInterest_Query::result_component_id() const {
  return _result_component_id;
}

::worker::List< std::uint32_t >& ComponentInterest_Query::result_component_id() {
  return _result_component_id;
}

ComponentInterest_Query& ComponentInterest_Query::set_result_component_id(const ::worker::List< std::uint32_t >& value) {
  _result_component_id = value;
  return *this;
}

const ::worker::Option< float >& ComponentInterest_Query::frequency() const {
  return _frequency;
}

::worker::Option< float >& ComponentInterest_Query::frequency() {
  return _frequency;
}

ComponentInterest_Query& ComponentInterest_Query::set_frequency(const ::worker::Option< float >& value) {
  _frequency = value;
  return *this;
}

// Implementation of ComponentInterest_RelativeBoxConstraint.
//----------------------------------------------------------------

ComponentInterest_RelativeBoxConstraint::ComponentInterest_RelativeBoxConstraint(const ::improbable::EdgeLength& edge_length)
: _edge_length{edge_length} {}

ComponentInterest_RelativeBoxConstraint::ComponentInterest_RelativeBoxConstraint() {}

bool ComponentInterest_RelativeBoxConstraint::operator==(const ComponentInterest_RelativeBoxConstraint& value) const {
  return
      _edge_length == value._edge_length;
}

bool ComponentInterest_RelativeBoxConstraint::operator!=(const ComponentInterest_RelativeBoxConstraint& value) const {
  return !operator==(value);
}

const ::improbable::EdgeLength& ComponentInterest_RelativeBoxConstraint::edge_length() const {
  return _edge_length;
}

::improbable::EdgeLength& ComponentInterest_RelativeBoxConstraint::edge_length() {
  return _edge_length;
}

ComponentInterest_RelativeBoxConstraint& ComponentInterest_RelativeBoxConstraint::set_edge_length(const ::improbable::EdgeLength& value) {
  _edge_length = value;
  return *this;
}

// Implementation of ComponentInterest_RelativeCylinderConstraint.
//----------------------------------------------------------------

ComponentInterest_RelativeCylinderConstraint::ComponentInterest_RelativeCylinderConstraint(double radius)
: _radius{radius} {}

ComponentInterest_RelativeCylinderConstraint::ComponentInterest_RelativeCylinderConstraint()
: _radius{0} {}

bool ComponentInterest_RelativeCylinderConstraint::operator==(const ComponentInterest_RelativeCylinderConstraint& value) const {
  return
      _radius == value._radius;
}

bool ComponentInterest_RelativeCylinderConstraint::operator!=(const ComponentInterest_RelativeCylinderConstraint& value) const {
  return !operator==(value);
}

double ComponentInterest_RelativeCylinderConstraint::radius() const {
  return _radius;
}

double& ComponentInterest_RelativeCylinderConstraint::radius() {
  return _radius;
}

ComponentInterest_RelativeCylinderConstraint& ComponentInterest_RelativeCylinderConstraint::set_radius(double value) {
  _radius = value;
  return *this;
}

// Implementation of ComponentInterest_RelativeSphereConstraint.
//----------------------------------------------------------------

ComponentInterest_RelativeSphereConstraint::ComponentInterest_RelativeSphereConstraint(double radius)
: _radius{radius} {}

ComponentInterest_RelativeSphereConstraint::ComponentInterest_RelativeSphereConstraint()
: _radius{0} {}

bool ComponentInterest_RelativeSphereConstraint::operator==(const ComponentInterest_RelativeSphereConstraint& value) const {
  return
      _radius == value._radius;
}

bool ComponentInterest_RelativeSphereConstraint::operator!=(const ComponentInterest_RelativeSphereConstraint& value) const {
  return !operator==(value);
}

double ComponentInterest_RelativeSphereConstraint::radius() const {
  return _radius;
}

double& ComponentInterest_RelativeSphereConstraint::radius() {
  return _radius;
}

ComponentInterest_RelativeSphereConstraint& ComponentInterest_RelativeSphereConstraint::set_radius(double value) {
  _radius = value;
  return *this;
}

// Implementation of ComponentInterest_SphereConstraint.
//----------------------------------------------------------------

ComponentInterest_SphereConstraint::ComponentInterest_SphereConstraint(
    const ::improbable::Coordinates& center,
    double radius)
: _center{center}
, _radius{radius} {}

ComponentInterest_SphereConstraint::ComponentInterest_SphereConstraint()
: _radius{0} {}

bool ComponentInterest_SphereConstraint::operator==(const ComponentInterest_SphereConstraint& value) const {
  return
      _center == value._center &&
      _radius == value._radius;
}

bool ComponentInterest_SphereConstraint::operator!=(const ComponentInterest_SphereConstraint& value) const {
  return !operator==(value);
}

const ::improbable::Coordinates& ComponentInterest_SphereConstraint::center() const {
  return _center;
}

::improbable::Coordinates& ComponentInterest_SphereConstraint::center() {
  return _center;
}

ComponentInterest_SphereConstraint& ComponentInterest_SphereConstraint::set_center(const ::improbable::Coordinates& value) {
  _center = value;
  return *this;
}

double ComponentInterest_SphereConstraint::radius() const {
  return _radius;
}

double& ComponentInterest_SphereConstraint::radius() {
  return _radius;
}

ComponentInterest_SphereConstraint& ComponentInterest_SphereConstraint::set_radius(double value) {
  _radius = value;
  return *this;
}

// Implementation of WorkerRequirementSet.
//----------------------------------------------------------------

WorkerRequirementSet::WorkerRequirementSet(const ::worker::List< ::improbable::WorkerAttributeSet >& attribute_set)
: _attribute_set{attribute_set} {}

WorkerRequirementSet::WorkerRequirementSet() {}

bool WorkerRequirementSet::operator==(const WorkerRequirementSet& value) const {
  return
      _attribute_set == value._attribute_set;
}

bool WorkerRequirementSet::operator!=(const WorkerRequirementSet& value) const {
  return !operator==(value);
}

const ::worker::List< ::improbable::WorkerAttributeSet >& WorkerRequirementSet::attribute_set() const {
  return _attribute_set;
}

::worker::List< ::improbable::WorkerAttributeSet >& WorkerRequirementSet::attribute_set() {
  return _attribute_set;
}

WorkerRequirementSet& WorkerRequirementSet::set_attribute_set(const ::worker::List< ::improbable::WorkerAttributeSet >& value) {
  _attribute_set = value;
  return *this;
}

// Implementation of EntityAclData.
//----------------------------------------------------------------

EntityAclData::EntityAclData(
    const ::improbable::WorkerRequirementSet& read_acl,
    const ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& component_write_acl)
: _read_acl{read_acl}
, _component_write_acl{component_write_acl} {}

EntityAclData::EntityAclData() {}

bool EntityAclData::operator==(const EntityAclData& value) const {
  return
      _read_acl == value._read_acl &&
      _component_write_acl == value._component_write_acl;
}

bool EntityAclData::operator!=(const EntityAclData& value) const {
  return !operator==(value);
}

const ::improbable::WorkerRequirementSet& EntityAclData::read_acl() const {
  return _read_acl;
}

::improbable::WorkerRequirementSet& EntityAclData::read_acl() {
  return _read_acl;
}

EntityAclData& EntityAclData::set_read_acl(const ::improbable::WorkerRequirementSet& value) {
  _read_acl = value;
  return *this;
}

const ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& EntityAclData::component_write_acl() const {
  return _component_write_acl;
}

::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& EntityAclData::component_write_acl() {
  return _component_write_acl;
}

EntityAclData& EntityAclData::set_component_write_acl(const ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& value) {
  _component_write_acl = value;
  return *this;
}

// Implementation of InterestData.
//----------------------------------------------------------------

InterestData::InterestData(const ::worker::Map< std::uint32_t, ::improbable::ComponentInterest >& component_interest)
: _component_interest{component_interest} {}

InterestData::InterestData() {}

bool InterestData::operator==(const InterestData& value) const {
  return
      _component_interest == value._component_interest;
}

bool InterestData::operator!=(const InterestData& value) const {
  return !operator==(value);
}

const ::worker::Map< std::uint32_t, ::improbable::ComponentInterest >& InterestData::component_interest() const {
  return _component_interest;
}

::worker::Map< std::uint32_t, ::improbable::ComponentInterest >& InterestData::component_interest() {
  return _component_interest;
}

InterestData& InterestData::set_component_interest(const ::worker::Map< std::uint32_t, ::improbable::ComponentInterest >& value) {
  _component_interest = value;
  return *this;
}

// Implementation of MetadataData.
//----------------------------------------------------------------

MetadataData::MetadataData(const std::string& entity_type)
: _entity_type{entity_type} {}

MetadataData::MetadataData() {}

bool MetadataData::operator==(const MetadataData& value) const {
  return
      _entity_type == value._entity_type;
}

bool MetadataData::operator!=(const MetadataData& value) const {
  return !operator==(value);
}

const std::string& MetadataData::entity_type() const {
  return _entity_type;
}

std::string& MetadataData::entity_type() {
  return _entity_type;
}

MetadataData& MetadataData::set_entity_type(const std::string& value) {
  _entity_type = value;
  return *this;
}

// Implementation of PersistenceData.
//----------------------------------------------------------------

PersistenceData::PersistenceData() {}

bool PersistenceData::operator==(const PersistenceData&) const {
  return true;
}

bool PersistenceData::operator!=(const PersistenceData& value) const {
  return !operator==(value);
}

// Implementation of PositionData.
//----------------------------------------------------------------

PositionData::PositionData(const ::improbable::Coordinates& coords)
: _coords{coords} {}

PositionData::PositionData() {}

bool PositionData::operator==(const PositionData& value) const {
  return
      _coords == value._coords;
}

bool PositionData::operator!=(const PositionData& value) const {
  return !operator==(value);
}

const ::improbable::Coordinates& PositionData::coords() const {
  return _coords;
}

::improbable::Coordinates& PositionData::coords() {
  return _coords;
}

PositionData& PositionData::set_coords(const ::improbable::Coordinates& value) {
  _coords = value;
  return *this;
}

// Implementation of WorkerAttributeSet.
//----------------------------------------------------------------

WorkerAttributeSet::WorkerAttributeSet(const ::worker::List< std::string >& attribute)
: _attribute{attribute} {}

WorkerAttributeSet::WorkerAttributeSet() {}

bool WorkerAttributeSet::operator==(const WorkerAttributeSet& value) const {
  return
      _attribute == value._attribute;
}

bool WorkerAttributeSet::operator!=(const WorkerAttributeSet& value) const {
  return !operator==(value);
}

const ::worker::List< std::string >& WorkerAttributeSet::attribute() const {
  return _attribute;
}

::worker::List< std::string >& WorkerAttributeSet::attribute() {
  return _attribute;
}

WorkerAttributeSet& WorkerAttributeSet::set_attribute(const ::worker::List< std::string >& value) {
  _attribute = value;
  return *this;
}

// Implementation of EntityAcl.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId EntityAcl::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
EntityAcl::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      50,
      nullptr,
      &::improbable::detail::VtableFree_EntityAcl,
      &::improbable::detail::VtableCopy_EntityAcl,
      &::improbable::detail::VtableDeserialize_EntityAcl,
      &::improbable::detail::VtableSerialize_EntityAcl,
  };
  return vtable;
}

bool EntityAcl::Update::operator==(const EntityAcl::Update& value) const {
  return
      _read_acl == value._read_acl &&
      _component_write_acl == value._component_write_acl;
}

bool EntityAcl::Update::operator!=(const EntityAcl::Update& value) const {
  return !operator==(value);
}

EntityAcl::Update EntityAcl::Update::FromInitialData(const ::improbable::EntityAclData& data) {
  EntityAcl::Update update;
  update._read_acl.emplace(data.read_acl());
  update._component_write_acl.emplace(data.component_write_acl());
  return update;
}

::improbable::EntityAclData EntityAcl::Update::ToInitialData() const {
  return ::improbable::EntityAclData(
      *_read_acl,
      *_component_write_acl);
}

void EntityAcl::Update::ApplyTo(::improbable::EntityAclData& data) const {
  if (_read_acl) {
    data.set_read_acl(*_read_acl);
  }
  if (_component_write_acl) {
    data.set_component_write_acl(*_component_write_acl);
  }
}

const ::worker::Option< ::improbable::WorkerRequirementSet >& EntityAcl::Update::read_acl() const {
  return _read_acl;
}

::worker::Option< ::improbable::WorkerRequirementSet >& EntityAcl::Update::read_acl() {
  return _read_acl;
}

EntityAcl::Update& EntityAcl::Update::set_read_acl(const ::improbable::WorkerRequirementSet& value) {
  _read_acl.emplace(value); return *this;
}

const ::worker::Option< ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > >& EntityAcl::Update::component_write_acl() const {
  return _component_write_acl;
}

::worker::Option< ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > >& EntityAcl::Update::component_write_acl() {
  return _component_write_acl;
}

EntityAcl::Update& EntityAcl::Update::set_component_write_acl(const ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& value) {
  _component_write_acl.emplace(value); return *this;
}

// Implementation of Metadata.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Metadata::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
Metadata::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      53,
      nullptr,
      &::improbable::detail::VtableFree_Metadata,
      &::improbable::detail::VtableCopy_Metadata,
      &::improbable::detail::VtableDeserialize_Metadata,
      &::improbable::detail::VtableSerialize_Metadata,
  };
  return vtable;
}

bool Metadata::Update::operator==(const Metadata::Update& value) const {
  return
      _entity_type == value._entity_type;
}

bool Metadata::Update::operator!=(const Metadata::Update& value) const {
  return !operator==(value);
}

Metadata::Update Metadata::Update::FromInitialData(const ::improbable::MetadataData& data) {
  Metadata::Update update;
  update._entity_type.emplace(data.entity_type());
  return update;
}

::improbable::MetadataData Metadata::Update::ToInitialData() const {
  return ::improbable::MetadataData(*_entity_type);
}

void Metadata::Update::ApplyTo(::improbable::MetadataData& data) const {
  if (_entity_type) {
    data.set_entity_type(*_entity_type);
  }
}

const ::worker::Option< std::string >& Metadata::Update::entity_type() const {
  return _entity_type;
}

::worker::Option< std::string >& Metadata::Update::entity_type() {
  return _entity_type;
}

Metadata::Update& Metadata::Update::set_entity_type(const std::string& value) {
  _entity_type.emplace(value); return *this;
}

// Implementation of Position.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Position::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
Position::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      54,
      nullptr,
      &::improbable::detail::VtableFree_Position,
      &::improbable::detail::VtableCopy_Position,
      &::improbable::detail::VtableDeserialize_Position,
      &::improbable::detail::VtableSerialize_Position,
  };
  return vtable;
}

bool Position::Update::operator==(const Position::Update& value) const {
  return
      _coords == value._coords;
}

bool Position::Update::operator!=(const Position::Update& value) const {
  return !operator==(value);
}

Position::Update Position::Update::FromInitialData(const ::improbable::PositionData& data) {
  Position::Update update;
  update._coords.emplace(data.coords());
  return update;
}

::improbable::PositionData Position::Update::ToInitialData() const {
  return ::improbable::PositionData(*_coords);
}

void Position::Update::ApplyTo(::improbable::PositionData& data) const {
  if (_coords) {
    data.set_coords(*_coords);
  }
}

const ::worker::Option< ::improbable::Coordinates >& Position::Update::coords() const {
  return _coords;
}

::worker::Option< ::improbable::Coordinates >& Position::Update::coords() {
  return _coords;
}

Position::Update& Position::Update::set_coords(const ::improbable::Coordinates& value) {
  _coords.emplace(value); return *this;
}

// Implementation of Persistence.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Persistence::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
Persistence::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      55,
      nullptr,
      &::improbable::detail::VtableFree_Persistence,
      &::improbable::detail::VtableCopy_Persistence,
      &::improbable::detail::VtableDeserialize_Persistence,
      &::improbable::detail::VtableSerialize_Persistence,
  };
  return vtable;
}

bool Persistence::Update::operator==(const Persistence::Update&) const {
  return true;
}

bool Persistence::Update::operator!=(const Persistence::Update& value) const {
  return !operator==(value);
}

Persistence::Update Persistence::Update::FromInitialData(const ::improbable::PersistenceData&) {
  return Persistence::Update{};
}

::improbable::PersistenceData Persistence::Update::ToInitialData() const {
  return ::improbable::PersistenceData();
}

void Persistence::Update::ApplyTo(::improbable::PersistenceData&) const {
}

// Implementation of Interest.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Interest::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
Interest::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      58,
      nullptr,
      &::improbable::detail::VtableFree_Interest,
      &::improbable::detail::VtableCopy_Interest,
      &::improbable::detail::VtableDeserialize_Interest,
      &::improbable::detail::VtableSerialize_Interest,
  };
  return vtable;
}

bool Interest::Update::operator==(const Interest::Update& value) const {
  return
      _component_interest == value._component_interest;
}

bool Interest::Update::operator!=(const Interest::Update& value) const {
  return !operator==(value);
}

Interest::Update Interest::Update::FromInitialData(const ::improbable::InterestData& data) {
  Interest::Update update;
  update._component_interest.emplace(data.component_interest());
  return update;
}

::improbable::InterestData Interest::Update::ToInitialData() const {
  return ::improbable::InterestData(*_component_interest);
}

void Interest::Update::ApplyTo(::improbable::InterestData& data) const {
  if (_component_interest) {
    data.set_component_interest(*_component_interest);
  }
}

const ::worker::Option< ::worker::Map< std::uint32_t, ::improbable::ComponentInterest > >& Interest::Update::component_interest() const {
  return _component_interest;
}

::worker::Option< ::worker::Map< std::uint32_t, ::improbable::ComponentInterest > >& Interest::Update::component_interest() {
  return _component_interest;
}

Interest::Update& Interest::Update::set_component_interest(const ::worker::Map< std::uint32_t, ::improbable::ComponentInterest >& value) {
  _component_interest.emplace(value); return *this;
}

}  // ::improbable

std::size_t std::hash< ::improbable::ComponentInterest >::operator()(const ::improbable::ComponentInterest& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::worker::List< ::improbable::ComponentInterest_Query > >{}(value.queries());
  return result;
}

std::size_t std::hash< ::improbable::Coordinates >::operator()(const ::improbable::Coordinates& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< double >{}(value.x());
  result = (result * 977) + std::hash< double >{}(value.y());
  result = (result * 977) + std::hash< double >{}(value.z());
  return result;
}

std::size_t std::hash< ::improbable::EdgeLength >::operator()(const ::improbable::EdgeLength& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< double >{}(value.x());
  result = (result * 977) + std::hash< double >{}(value.y());
  result = (result * 977) + std::hash< double >{}(value.z());
  return result;
}

std::size_t std::hash< ::improbable::ComponentInterest_BoxConstraint >::operator()(const ::improbable::ComponentInterest_BoxConstraint& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::improbable::Coordinates >{}(value.center());
  result = (result * 977) + std::hash< ::improbable::EdgeLength >{}(value.edge_length());
  return result;
}

std::size_t std::hash< ::improbable::ComponentInterest_CylinderConstraint >::operator()(const ::improbable::ComponentInterest_CylinderConstraint& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::improbable::Coordinates >{}(value.center());
  result = (result * 977) + std::hash< double >{}(value.radius());
  return result;
}

std::size_t std::hash< ::improbable::ComponentInterest_QueryConstraint >::operator()(const ::improbable::ComponentInterest_QueryConstraint& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::worker::Option< ::improbable::ComponentInterest_SphereConstraint > >{}(value.sphere_constraint());
  result = (result * 977) + std::hash< ::worker::Option< ::improbable::ComponentInterest_CylinderConstraint > >{}(value.cylinder_constraint());
  result = (result * 977) + std::hash< ::worker::Option< ::improbable::ComponentInterest_BoxConstraint > >{}(value.box_constraint());
  result = (result * 977) + std::hash< ::worker::Option< ::improbable::ComponentInterest_RelativeSphereConstraint > >{}(value.relative_sphere_constraint());
  result = (result * 977) + std::hash< ::worker::Option< ::improbable::ComponentInterest_RelativeCylinderConstraint > >{}(value.relative_cylinder_constraint());
  result = (result * 977) + std::hash< ::worker::Option< ::improbable::ComponentInterest_RelativeBoxConstraint > >{}(value.relative_box_constraint());
  result = (result * 977) + std::hash< ::worker::Option< std::int64_t > >{}(value.entity_id_constraint());
  result = (result * 977) + std::hash< ::worker::Option< std::uint32_t > >{}(value.component_constraint());
  result = (result * 977) + std::hash< ::worker::List< ::improbable::ComponentInterest_QueryConstraint > >{}(value.and_constraint());
  result = (result * 977) + std::hash< ::worker::List< ::improbable::ComponentInterest_QueryConstraint > >{}(value.or_constraint());
  return result;
}

std::size_t std::hash< ::improbable::ComponentInterest_Query >::operator()(const ::improbable::ComponentInterest_Query& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::improbable::ComponentInterest_QueryConstraint >{}(value.constraint());
  result = (result * 977) + std::hash< ::worker::Option< bool > >{}(value.full_snapshot_result());
  result = (result * 977) + std::hash< ::worker::List< std::uint32_t > >{}(value.result_component_id());
  result = (result * 977) + std::hash< ::worker::Option< float > >{}(value.frequency());
  return result;
}

std::size_t std::hash< ::improbable::ComponentInterest_RelativeBoxConstraint >::operator()(const ::improbable::ComponentInterest_RelativeBoxConstraint& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::improbable::EdgeLength >{}(value.edge_length());
  return result;
}

std::size_t std::hash< ::improbable::ComponentInterest_RelativeCylinderConstraint >::operator()(const ::improbable::ComponentInterest_RelativeCylinderConstraint& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< double >{}(value.radius());
  return result;
}

std::size_t std::hash< ::improbable::ComponentInterest_RelativeSphereConstraint >::operator()(const ::improbable::ComponentInterest_RelativeSphereConstraint& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< double >{}(value.radius());
  return result;
}

std::size_t std::hash< ::improbable::ComponentInterest_SphereConstraint >::operator()(const ::improbable::ComponentInterest_SphereConstraint& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::improbable::Coordinates >{}(value.center());
  result = (result * 977) + std::hash< double >{}(value.radius());
  return result;
}

std::size_t std::hash< ::improbable::WorkerRequirementSet >::operator()(const ::improbable::WorkerRequirementSet& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::worker::List< ::improbable::WorkerAttributeSet > >{}(value.attribute_set());
  return result;
}

std::size_t std::hash< ::improbable::EntityAclData >::operator()(const ::improbable::EntityAclData& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::improbable::WorkerRequirementSet >{}(value.read_acl());
  result = (result * 977) + std::hash< ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > >{}(value.component_write_acl());
  return result;
}

std::size_t std::hash< ::improbable::InterestData >::operator()(const ::improbable::InterestData& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::worker::Map< std::uint32_t, ::improbable::ComponentInterest > >{}(value.component_interest());
  return result;
}

std::size_t std::hash< ::improbable::MetadataData >::operator()(const ::improbable::MetadataData& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< std::string >{}(value.entity_type());
  return result;
}

std::size_t std::hash< ::improbable::PersistenceData >::operator()(const ::improbable::PersistenceData& ) const {
  size_t result = 1327;
  return result;
}

std::size_t std::hash< ::improbable::PositionData >::operator()(const ::improbable::PositionData& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::improbable::Coordinates >{}(value.coords());
  return result;
}

std::size_t std::hash< ::improbable::WorkerAttributeSet >::operator()(const ::improbable::WorkerAttributeSet& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::worker::List< std::string > >{}(value.attribute());
  return result;
}

// Generated by SpatialOS codegen. DO NOT EDIT!
// source: othello.schema
#include "othello.h"

namespace othello {

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Write_ColorData(
    const ::othello::ColorData& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddBool(object, 1, static_cast<std::uint8_t>(data.black()));
}

::othello::ColorData Read_ColorData(::worker::detail::internal::Pbio_Object* object) {
  auto _black = ::worker::detail::internal::Pbio_GetBool(object, 1) != 0;
  return {
      std::move(_black)};
}

void Write_CreatePlayerResult(
    const ::othello::CreatePlayerResult& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddBool(object, 1, static_cast<std::uint8_t>(data.black()));
}

::othello::CreatePlayerResult Read_CreatePlayerResult(::worker::detail::internal::Pbio_Object* object) {
  auto _black = ::worker::detail::internal::Pbio_GetBool(object, 1) != 0;
  return {
      std::move(_black)};
}

void Write_FindColorRequest(
    const ::othello::FindColorRequest& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddUint32(object, 1, static_cast<std::uint32_t>(data.dir()));
  ::worker::detail::internal::Pbio_AddBool(object, 2, static_cast<std::uint8_t>(data.black()));
}

::othello::FindColorRequest Read_FindColorRequest(::worker::detail::internal::Pbio_Object* object) {
  auto _dir = static_cast< ::othello::Direction >(::worker::detail::internal::Pbio_GetUint32(object, 1));
  auto _black = ::worker::detail::internal::Pbio_GetBool(object, 2) != 0;
  return {
      std::move(_dir),
      std::move(_black)};
}

void Write_GameData(const ::othello::GameData&, ::worker::detail::internal::Pbio_Object*) {}

::othello::GameData Read_GameData(::worker::detail::internal::Pbio_Object*) {
  return {};
}

void Write_PlaceDiscRequest(
    const ::othello::PlaceDiscRequest& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddInt64(object, 1, data.x());
  ::worker::detail::internal::Pbio_AddInt64(object, 2, data.z());
}

::othello::PlaceDiscRequest Read_PlaceDiscRequest(::worker::detail::internal::Pbio_Object* object) {
  auto _x = ::worker::detail::internal::Pbio_GetInt64(object, 1);
  auto _z = ::worker::detail::internal::Pbio_GetInt64(object, 2);
  return {
      std::move(_x),
      std::move(_z)};
}

void Write_PlayerData(
    const ::othello::PlayerData& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddBytes(object, 1, reinterpret_cast<const std::uint8_t*>(data.worker().data()), static_cast<std::uint32_t>(data.worker().size()));
}

::othello::PlayerData Read_PlayerData(::worker::detail::internal::Pbio_Object* object) {
  auto _worker = [object] { auto _buffer = reinterpret_cast<const char*>(::worker::detail::internal::Pbio_GetBytes(object, 1)); return std::string{_buffer, _buffer + ::worker::detail::internal::Pbio_GetBytesLength(object, 1)}; }();
  return {
      std::move(_worker)};
}

void Write_SuccessResult(
    const ::othello::SuccessResult& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddBool(object, 1, static_cast<std::uint8_t>(data.success()));
}

::othello::SuccessResult Read_SuccessResult(::worker::detail::internal::Pbio_Object* object) {
  auto _success = ::worker::detail::internal::Pbio_GetBool(object, 1) != 0;
  return {
      std::move(_success)};
}

void Write_TurnTakerData(const ::othello::TurnTakerData&, ::worker::detail::internal::Pbio_Object*) {}

::othello::TurnTakerData Read_TurnTakerData(::worker::detail::internal::Pbio_Object*) {
  return {};
}

void Write_Void(const ::othello::Void&, ::worker::detail::internal::Pbio_Object*) {}

::othello::Void Read_Void(::worker::detail::internal::Pbio_Object*) {
  return {};
}

namespace {

void VtableFree_Game(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::othello::Game::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::othello::GameData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_Game >::free(handle);
  }
}

void* VtableCopy_Game(
    ::worker::ComponentId, void*, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::othello::Game::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::othello::GameData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_Game >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_Game(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::othello::Game::Update >::allocate();
    {
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::othello::GameData >::allocate(::othello::detail::Read_GameData(::worker::detail::internal::Pbio_GetObject(root, 1000)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    auto command_object = ::worker::detail::internal::Pbio_GetObject(root, 1000);
    if (::worker::detail::internal::Pbio_GetObjectCount(command_object, 1)) {
      *handle_out = ::worker::detail::ClientHandle< ::othello::detail::GenericCommandObject_Game >::allocate(
        ::othello::Game::Commands::CreatePlayer::CommandId,
        ::othello::detail::Read_Void(::worker::detail::internal::Pbio_GetObject(command_object, 1)));
    }
    if (::worker::detail::internal::Pbio_GetObjectCount(command_object, 3)) {
      *handle_out = ::worker::detail::ClientHandle< ::othello::detail::GenericCommandObject_Game >::allocate(
        ::othello::Game::Commands::PlaceDisc::CommandId,
        ::othello::detail::Read_PlaceDiscRequest(::worker::detail::internal::Pbio_GetObject(command_object, 3)));
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    auto command_object = ::worker::detail::internal::Pbio_GetObject(root, 1000);
    if (::worker::detail::internal::Pbio_GetObjectCount(command_object, 2)) {
      *handle_out = ::worker::detail::ClientHandle< ::othello::detail::GenericCommandObject_Game >::allocate(
        ::othello::Game::Commands::CreatePlayer::CommandId,
        ::othello::detail::Read_CreatePlayerResult(::worker::detail::internal::Pbio_GetObject(command_object, 2)));
    }
    if (::worker::detail::internal::Pbio_GetObjectCount(command_object, 4)) {
      *handle_out = ::worker::detail::ClientHandle< ::othello::detail::GenericCommandObject_Game >::allocate(
        ::othello::Game::Commands::PlaceDisc::CommandId,
        ::othello::detail::Read_SuccessResult(::worker::detail::internal::Pbio_GetObject(command_object, 4)));
    }
  }
  return true;
}

void VtableSerialize_Game(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    {
      ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 1000);
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::othello::detail::Write_GameData(
        ::worker::detail::ClientHandle< ::othello::GameData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 1000));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    const auto& data = ::worker::detail::ClientHandle< GenericCommandObject_Game >::get(handle);
    auto command_object = ::worker::detail::internal::Pbio_AddObject(root, 1000);
    if (data.CommandId == ::othello::Game::Commands::CreatePlayer::CommandId) {
      ::othello::detail::Write_Void(*data.CommandObject.data< ::othello::Void >(), ::worker::detail::internal::Pbio_AddObject(command_object, 1));
    }
    if (data.CommandId == ::othello::Game::Commands::PlaceDisc::CommandId) {
      ::othello::detail::Write_PlaceDiscRequest(*data.CommandObject.data< ::othello::PlaceDiscRequest >(), ::worker::detail::internal::Pbio_AddObject(command_object, 3));
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    const auto& data = ::worker::detail::ClientHandle< GenericCommandObject_Game >::get(handle);
    auto command_object = ::worker::detail::internal::Pbio_AddObject(root, 1000);
    if (data.CommandId == ::othello::Game::Commands::CreatePlayer::CommandId) {
      ::othello::detail::Write_CreatePlayerResult(*data.CommandObject.data< ::othello::CreatePlayerResult >(), ::worker::detail::internal::Pbio_AddObject(command_object, 2));
    }
    if (data.CommandId == ::othello::Game::Commands::PlaceDisc::CommandId) {
      ::othello::detail::Write_SuccessResult(*data.CommandObject.data< ::othello::SuccessResult >(), ::worker::detail::internal::Pbio_AddObject(command_object, 4));
    }
  }
}

}  // anonymous namespace

namespace {

void VtableFree_Color(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::othello::Color::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::othello::ColorData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_Color >::free(handle);
  }
}

void* VtableCopy_Color(
    ::worker::ComponentId, void*, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::othello::Color::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::othello::ColorData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_Color >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_Color(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::othello::Color::Update >::allocate();
    auto* object =
       &::worker::detail::ClientHandle< ::othello::Color::Update >::get_mutable(*handle_out);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::worker::detail::internal::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::worker::detail::internal::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::worker::detail::internal::Pbio_GetObject(
          ::worker::detail::internal::Pbio_GetObject(root, /* entity_state */ 2), 1001);
      if (::worker::detail::internal::Pbio_GetBoolCount(state_object, 1)) {
        auto _black = ::worker::detail::internal::Pbio_GetBool(state_object, 1) != 0;
        object->black().emplace(std::move(_black));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::othello::ColorData >::allocate(::othello::detail::Read_ColorData(::worker::detail::internal::Pbio_GetObject(root, 1001)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    auto command_object = ::worker::detail::internal::Pbio_GetObject(root, 1001);
    if (::worker::detail::internal::Pbio_GetObjectCount(command_object, 1)) {
      *handle_out = ::worker::detail::ClientHandle< ::othello::detail::GenericCommandObject_Color >::allocate(
        ::othello::Color::Commands::FindColor::CommandId,
        ::othello::detail::Read_FindColorRequest(::worker::detail::internal::Pbio_GetObject(command_object, 1)));
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    auto command_object = ::worker::detail::internal::Pbio_GetObject(root, 1001);
    if (::worker::detail::internal::Pbio_GetObjectCount(command_object, 2)) {
      *handle_out = ::worker::detail::ClientHandle< ::othello::detail::GenericCommandObject_Color >::allocate(
        ::othello::Color::Commands::FindColor::CommandId,
        ::othello::detail::Read_SuccessResult(::worker::detail::internal::Pbio_GetObject(command_object, 2)));
    }
  }
  return true;
}

void VtableSerialize_Color(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    const auto& data = ::worker::detail::ClientHandle< ::othello::Color::Update >::get(handle);
    {
      auto state_object = ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 1001);
      if (data.black()) {
        ::worker::detail::internal::Pbio_AddBool(state_object, 1, static_cast<std::uint8_t>((*data.black())));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::othello::detail::Write_ColorData(
        ::worker::detail::ClientHandle< ::othello::ColorData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 1001));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    const auto& data = ::worker::detail::ClientHandle< GenericCommandObject_Color >::get(handle);
    auto command_object = ::worker::detail::internal::Pbio_AddObject(root, 1001);
    if (data.CommandId == ::othello::Color::Commands::FindColor::CommandId) {
      ::othello::detail::Write_FindColorRequest(*data.CommandObject.data< ::othello::FindColorRequest >(), ::worker::detail::internal::Pbio_AddObject(command_object, 1));
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    const auto& data = ::worker::detail::ClientHandle< GenericCommandObject_Color >::get(handle);
    auto command_object = ::worker::detail::internal::Pbio_AddObject(root, 1001);
    if (data.CommandId == ::othello::Color::Commands::FindColor::CommandId) {
      ::othello::detail::Write_SuccessResult(*data.CommandObject.data< ::othello::SuccessResult >(), ::worker::detail::internal::Pbio_AddObject(command_object, 2));
    }
  }
}

}  // anonymous namespace

namespace {

void VtableFree_Player(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::othello::Player::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::othello::PlayerData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_Player >::free(handle);
  }
}

void* VtableCopy_Player(
    ::worker::ComponentId, void*, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::othello::Player::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::othello::PlayerData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_Player >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_Player(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::othello::Player::Update >::allocate();
    auto* object =
       &::worker::detail::ClientHandle< ::othello::Player::Update >::get_mutable(*handle_out);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::worker::detail::internal::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::worker::detail::internal::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::worker::detail::internal::Pbio_GetObject(
          ::worker::detail::internal::Pbio_GetObject(root, /* entity_state */ 2), 1002);
      if (::worker::detail::internal::Pbio_GetBytesCount(state_object, 1)) {
        auto _worker = [state_object] { auto _buffer = reinterpret_cast<const char*>(::worker::detail::internal::Pbio_GetBytes(state_object, 1)); return std::string{_buffer, _buffer + ::worker::detail::internal::Pbio_GetBytesLength(state_object, 1)}; }();
        object->worker().emplace(std::move(_worker));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::othello::PlayerData >::allocate(::othello::detail::Read_PlayerData(::worker::detail::internal::Pbio_GetObject(root, 1002)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
  }
  return true;
}

void VtableSerialize_Player(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    const auto& data = ::worker::detail::ClientHandle< ::othello::Player::Update >::get(handle);
    {
      auto state_object = ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 1002);
      if (data.worker()) {
        ::worker::detail::internal::Pbio_AddBytes(state_object, 1, reinterpret_cast<const std::uint8_t*>((*data.worker()).data()), static_cast<std::uint32_t>((*data.worker()).size()));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::othello::detail::Write_PlayerData(
        ::worker::detail::ClientHandle< ::othello::PlayerData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 1002));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    ::worker::detail::internal::Pbio_AddObject(root, 1002);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::internal::Pbio_AddObject(root, 1002);
  }
}

}  // anonymous namespace

namespace {

void VtableFree_TurnTaker(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::othello::TurnTaker::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::othello::TurnTakerData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_TurnTaker >::free(handle);
  }
}

void* VtableCopy_TurnTaker(
    ::worker::ComponentId, void*, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::othello::TurnTaker::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::othello::TurnTakerData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_TurnTaker >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_TurnTaker(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::othello::TurnTaker::Update >::allocate();
    {
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::othello::TurnTakerData >::allocate(::othello::detail::Read_TurnTakerData(::worker::detail::internal::Pbio_GetObject(root, 1003)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    auto command_object = ::worker::detail::internal::Pbio_GetObject(root, 1003);
    if (::worker::detail::internal::Pbio_GetObjectCount(command_object, 1)) {
      *handle_out = ::worker::detail::ClientHandle< ::othello::detail::GenericCommandObject_TurnTaker >::allocate(
        ::othello::TurnTaker::Commands::YourTurn::CommandId,
        ::othello::detail::Read_Void(::worker::detail::internal::Pbio_GetObject(command_object, 1)));
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    auto command_object = ::worker::detail::internal::Pbio_GetObject(root, 1003);
    if (::worker::detail::internal::Pbio_GetObjectCount(command_object, 2)) {
      *handle_out = ::worker::detail::ClientHandle< ::othello::detail::GenericCommandObject_TurnTaker >::allocate(
        ::othello::TurnTaker::Commands::YourTurn::CommandId,
        ::othello::detail::Read_Void(::worker::detail::internal::Pbio_GetObject(command_object, 2)));
    }
  }
  return true;
}

void VtableSerialize_TurnTaker(
    ::worker::ComponentId, void*, std::uint8_t handle_type,
    void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    {
      ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 1003);
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::othello::detail::Write_TurnTakerData(
        ::worker::detail::ClientHandle< ::othello::TurnTakerData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 1003));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    const auto& data = ::worker::detail::ClientHandle< GenericCommandObject_TurnTaker >::get(handle);
    auto command_object = ::worker::detail::internal::Pbio_AddObject(root, 1003);
    if (data.CommandId == ::othello::TurnTaker::Commands::YourTurn::CommandId) {
      ::othello::detail::Write_Void(*data.CommandObject.data< ::othello::Void >(), ::worker::detail::internal::Pbio_AddObject(command_object, 1));
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    const auto& data = ::worker::detail::ClientHandle< GenericCommandObject_TurnTaker >::get(handle);
    auto command_object = ::worker::detail::internal::Pbio_AddObject(root, 1003);
    if (data.CommandId == ::othello::TurnTaker::Commands::YourTurn::CommandId) {
      ::othello::detail::Write_Void(*data.CommandObject.data< ::othello::Void >(), ::worker::detail::internal::Pbio_AddObject(command_object, 2));
    }
  }
}

}  // anonymous namespace

}  // ::detail

// Implementation of ColorData.
//----------------------------------------------------------------

ColorData::ColorData(bool black)
: _black{black} {}

ColorData::ColorData()
: _black{0} {}

bool ColorData::operator==(const ColorData& value) const {
  return
      _black == value._black;
}

bool ColorData::operator!=(const ColorData& value) const {
  return !operator==(value);
}

bool ColorData::black() const {
  return _black;
}

bool& ColorData::black() {
  return _black;
}

ColorData& ColorData::set_black(bool value) {
  _black = value;
  return *this;
}

// Implementation of CreatePlayerResult.
//----------------------------------------------------------------

CreatePlayerResult::CreatePlayerResult(bool black)
: _black{black} {}

CreatePlayerResult::CreatePlayerResult()
: _black{0} {}

bool CreatePlayerResult::operator==(const CreatePlayerResult& value) const {
  return
      _black == value._black;
}

bool CreatePlayerResult::operator!=(const CreatePlayerResult& value) const {
  return !operator==(value);
}

bool CreatePlayerResult::black() const {
  return _black;
}

bool& CreatePlayerResult::black() {
  return _black;
}

CreatePlayerResult& CreatePlayerResult::set_black(bool value) {
  _black = value;
  return *this;
}

// Implementation of FindColorRequest.
//----------------------------------------------------------------

FindColorRequest::FindColorRequest(
    ::othello::Direction dir,
    bool black)
: _dir{dir}
, _black{black} {}

FindColorRequest::FindColorRequest()
: _dir{::othello::Direction::NORTH}
, _black{0} {}

bool FindColorRequest::operator==(const FindColorRequest& value) const {
  return
      _dir == value._dir &&
      _black == value._black;
}

bool FindColorRequest::operator!=(const FindColorRequest& value) const {
  return !operator==(value);
}

::othello::Direction FindColorRequest::dir() const {
  return _dir;
}

::othello::Direction& FindColorRequest::dir() {
  return _dir;
}

FindColorRequest& FindColorRequest::set_dir(::othello::Direction value) {
  _dir = value;
  return *this;
}

bool FindColorRequest::black() const {
  return _black;
}

bool& FindColorRequest::black() {
  return _black;
}

FindColorRequest& FindColorRequest::set_black(bool value) {
  _black = value;
  return *this;
}

// Implementation of GameData.
//----------------------------------------------------------------

GameData::GameData() {}

bool GameData::operator==(const GameData&) const {
  return true;
}

bool GameData::operator!=(const GameData& value) const {
  return !operator==(value);
}

// Implementation of PlaceDiscRequest.
//----------------------------------------------------------------

PlaceDiscRequest::PlaceDiscRequest(
    std::int64_t x,
    std::int64_t z)
: _x{x}
, _z{z} {}

PlaceDiscRequest::PlaceDiscRequest()
: _x{0}
, _z{0} {}

bool PlaceDiscRequest::operator==(const PlaceDiscRequest& value) const {
  return
      _x == value._x &&
      _z == value._z;
}

bool PlaceDiscRequest::operator!=(const PlaceDiscRequest& value) const {
  return !operator==(value);
}

std::int64_t PlaceDiscRequest::x() const {
  return _x;
}

std::int64_t& PlaceDiscRequest::x() {
  return _x;
}

PlaceDiscRequest& PlaceDiscRequest::set_x(std::int64_t value) {
  _x = value;
  return *this;
}

std::int64_t PlaceDiscRequest::z() const {
  return _z;
}

std::int64_t& PlaceDiscRequest::z() {
  return _z;
}

PlaceDiscRequest& PlaceDiscRequest::set_z(std::int64_t value) {
  _z = value;
  return *this;
}

// Implementation of PlayerData.
//----------------------------------------------------------------

PlayerData::PlayerData(const std::string& worker)
: _worker{worker} {}

PlayerData::PlayerData() {}

bool PlayerData::operator==(const PlayerData& value) const {
  return
      _worker == value._worker;
}

bool PlayerData::operator!=(const PlayerData& value) const {
  return !operator==(value);
}

const std::string& PlayerData::worker() const {
  return _worker;
}

std::string& PlayerData::worker() {
  return _worker;
}

PlayerData& PlayerData::set_worker(const std::string& value) {
  _worker = value;
  return *this;
}

// Implementation of SuccessResult.
//----------------------------------------------------------------

SuccessResult::SuccessResult(bool success)
: _success{success} {}

SuccessResult::SuccessResult()
: _success{0} {}

bool SuccessResult::operator==(const SuccessResult& value) const {
  return
      _success == value._success;
}

bool SuccessResult::operator!=(const SuccessResult& value) const {
  return !operator==(value);
}

bool SuccessResult::success() const {
  return _success;
}

bool& SuccessResult::success() {
  return _success;
}

SuccessResult& SuccessResult::set_success(bool value) {
  _success = value;
  return *this;
}

// Implementation of TurnTakerData.
//----------------------------------------------------------------

TurnTakerData::TurnTakerData() {}

bool TurnTakerData::operator==(const TurnTakerData&) const {
  return true;
}

bool TurnTakerData::operator!=(const TurnTakerData& value) const {
  return !operator==(value);
}

// Implementation of Void.
//----------------------------------------------------------------

Void::Void() {}

bool Void::operator==(const Void&) const {
  return true;
}

bool Void::operator!=(const Void& value) const {
  return !operator==(value);
}

// Implementation of Game.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Game::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
Game::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      1000,
      nullptr,
      &::othello::detail::VtableFree_Game,
      &::othello::detail::VtableCopy_Game,
      &::othello::detail::VtableDeserialize_Game,
      &::othello::detail::VtableSerialize_Game,
  };
  return vtable;
}

constexpr const std::uint32_t Game::Commands::CreatePlayer::CommandId;

constexpr const std::uint32_t Game::Commands::PlaceDisc::CommandId;

bool Game::Update::operator==(const Game::Update&) const {
  return true;
}

bool Game::Update::operator!=(const Game::Update& value) const {
  return !operator==(value);
}

Game::Update Game::Update::FromInitialData(const ::othello::GameData&) {
  return Game::Update{};
}

::othello::GameData Game::Update::ToInitialData() const {
  return ::othello::GameData();
}

void Game::Update::ApplyTo(::othello::GameData&) const {
}

// Implementation of Color.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Color::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
Color::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      1001,
      nullptr,
      &::othello::detail::VtableFree_Color,
      &::othello::detail::VtableCopy_Color,
      &::othello::detail::VtableDeserialize_Color,
      &::othello::detail::VtableSerialize_Color,
  };
  return vtable;
}

constexpr const std::uint32_t Color::Commands::FindColor::CommandId;

bool Color::Update::operator==(const Color::Update& value) const {
  return
      _black == value._black;
}

bool Color::Update::operator!=(const Color::Update& value) const {
  return !operator==(value);
}

Color::Update Color::Update::FromInitialData(const ::othello::ColorData& data) {
  Color::Update update;
  update._black.emplace(data.black());
  return update;
}

::othello::ColorData Color::Update::ToInitialData() const {
  return ::othello::ColorData(*_black);
}

void Color::Update::ApplyTo(::othello::ColorData& data) const {
  if (_black) {
    data.set_black(*_black);
  }
}

const ::worker::Option< bool >& Color::Update::black() const {
  return _black;
}

::worker::Option< bool >& Color::Update::black() {
  return _black;
}

Color::Update& Color::Update::set_black(bool value) {
  _black.emplace(value); return *this;
}

// Implementation of Player.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Player::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
Player::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      1002,
      nullptr,
      &::othello::detail::VtableFree_Player,
      &::othello::detail::VtableCopy_Player,
      &::othello::detail::VtableDeserialize_Player,
      &::othello::detail::VtableSerialize_Player,
  };
  return vtable;
}

bool Player::Update::operator==(const Player::Update& value) const {
  return
      _worker == value._worker;
}

bool Player::Update::operator!=(const Player::Update& value) const {
  return !operator==(value);
}

Player::Update Player::Update::FromInitialData(const ::othello::PlayerData& data) {
  Player::Update update;
  update._worker.emplace(data.worker());
  return update;
}

::othello::PlayerData Player::Update::ToInitialData() const {
  return ::othello::PlayerData(*_worker);
}

void Player::Update::ApplyTo(::othello::PlayerData& data) const {
  if (_worker) {
    data.set_worker(*_worker);
  }
}

const ::worker::Option< std::string >& Player::Update::worker() const {
  return _worker;
}

::worker::Option< std::string >& Player::Update::worker() {
  return _worker;
}

Player::Update& Player::Update::set_worker(const std::string& value) {
  _worker.emplace(value); return *this;
}

// Implementation of TurnTaker.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId TurnTaker::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
TurnTaker::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      1003,
      nullptr,
      &::othello::detail::VtableFree_TurnTaker,
      &::othello::detail::VtableCopy_TurnTaker,
      &::othello::detail::VtableDeserialize_TurnTaker,
      &::othello::detail::VtableSerialize_TurnTaker,
  };
  return vtable;
}

constexpr const std::uint32_t TurnTaker::Commands::YourTurn::CommandId;

bool TurnTaker::Update::operator==(const TurnTaker::Update&) const {
  return true;
}

bool TurnTaker::Update::operator!=(const TurnTaker::Update& value) const {
  return !operator==(value);
}

TurnTaker::Update TurnTaker::Update::FromInitialData(const ::othello::TurnTakerData&) {
  return TurnTaker::Update{};
}

::othello::TurnTakerData TurnTaker::Update::ToInitialData() const {
  return ::othello::TurnTakerData();
}

void TurnTaker::Update::ApplyTo(::othello::TurnTakerData&) const {
}

}  // ::othello

std::size_t std::hash< ::othello::Direction >::operator()(::othello::Direction value) const {
  return static_cast<std::size_t>(value);
}

std::size_t std::hash< ::othello::ColorData >::operator()(const ::othello::ColorData& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< bool >{}(value.black());
  return result;
}

std::size_t std::hash< ::othello::CreatePlayerResult >::operator()(const ::othello::CreatePlayerResult& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< bool >{}(value.black());
  return result;
}

std::size_t std::hash< ::othello::FindColorRequest >::operator()(const ::othello::FindColorRequest& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::othello::Direction >{}(value.dir());
  result = (result * 977) + std::hash< bool >{}(value.black());
  return result;
}

std::size_t std::hash< ::othello::GameData >::operator()(const ::othello::GameData& ) const {
  size_t result = 1327;
  return result;
}

std::size_t std::hash< ::othello::PlaceDiscRequest >::operator()(const ::othello::PlaceDiscRequest& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< std::int64_t >{}(value.x());
  result = (result * 977) + std::hash< std::int64_t >{}(value.z());
  return result;
}

std::size_t std::hash< ::othello::PlayerData >::operator()(const ::othello::PlayerData& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< std::string >{}(value.worker());
  return result;
}

std::size_t std::hash< ::othello::SuccessResult >::operator()(const ::othello::SuccessResult& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< bool >{}(value.success());
  return result;
}

std::size_t std::hash< ::othello::TurnTakerData >::operator()(const ::othello::TurnTakerData& ) const {
  size_t result = 1327;
  return result;
}

std::size_t std::hash< ::othello::Void >::operator()(const ::othello::Void& ) const {
  size_t result = 1327;
  return result;
}
